<div xmlns="http://www.w3.org/1999/xhtml">
 <h1>Принципы для разработки: KISS, DRY, YAGNI, BDUF, SOLID, APO и бритва Оккама</h1>
<br>
Хорошему программисту необходимо уметь совмещать свои навыки со здравым смыслом. Все дело в прагматизме и навыке выбора лучшего решения для вашей проблемы. Когда вы сталкиваетесь с проблемой при разработке ПО, вы можете воспользоваться базовыми принципами, которые помогут в выборе самого правильного подхода.<br>
<br>
В этом тексте приводится набор принципов, которые должен знать любой разработчик, и которые следует периодически освежать в памяти. Считайте их своим секретным оружием при программировании.<br>
<br>
Последовательное применение этих принципов упростит ваш переход от миддла к сеньору. Вы можете обнаружить, что некоторые (вероятно) вы применяете интуитивно.<br>
<br>
Принципов много. Мы остановимся на семи самых важных. Их использование поможет вам в развитии и позволит стать лучшим программистом.<br>
<br>
<h3>1. YAGNI</h3> <i>You Aren’t Gonna Need It / Вам это не понадобится</i><br>
<br>
Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже. <br>
<br>
Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.<br>
<br>
Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.<br>
<a name="habracut"></a><br>
<h3>2. DRY</h3> <i>Don’t Repeat Yourself / Не повторяйтесь</i> <br>
<br>
Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».<br>
<br>
Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?<br>
<br>
<blockquote>В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.<br>
<br>
– Википедия</blockquote><br>
<br>
Использование SSOT позволит создать более прочную и понятную кодовую базу.<br>
<br>
Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.<br>
<br>
В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.<br>
<br>
<h3>3. KISS</h3><i> Keep It Simple, Stupid / Будь проще</i><br>
<br>
Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее.<br>
<br>
У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и рекламная метафора.<br>
<br>
Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.<br>
<br>
Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.<br>
<br>
Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.<br>
<br>
<h3>4. Big Design Up Front</h3> <i>Глобальное проектирование прежде всего</i><br>
<br>
Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано.<br>
<br>
<blockquote>Зачастую продумывание решений избавляло нас от проблем при разработке… Внесение изменений в спецификации занимало час или два. Если бы мы вносили эти изменения в код, на это уходили бы недели. Я даже не могу выразить, насколько сильно я верю в важность проектирования перед реализацией, хотя адепты экстремального программирования предали эту практику анафеме. Я экономил время и делал свои продукты лучше, используя BDUF, и я горжусь этим фактом, чтобы там ни говорили фанатики экстремального программирования. Они просто ошибаются, иначе сказать не могу.<br>
<br>
 — Джоел Спольски</blockquote><br>
Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив план, вы избавите себя от необходимости раз за разом начинать с нуля.<br>
<br>
Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех.<br>
<br>
Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть другого шанса справиться с этими ошибками.<br>
<br>
<h3>5. SOLID</h3><br>
Это наиболее известный принцип разработки ПО. Solid — это аббревиатура от:<br>
<br>
<b>S) Single-responsibility principle /Принцип единственной ответственности </b><br>
<br>
Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. Вот пример:<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> saveTodo = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">try</span> {
        response = <span class="hljs-keyword">await</span> saveTodoApi(); 
        showSuccessPop(<span class="hljs-string">'Success'</span>); 
        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'/successPage'</span>;
    } <span class="hljs-keyword">catch</span> (error) { 
        showErrorPopup(<span class="hljs-string">`Error: <span class="hljs-subst">${error}</span> `</span>);
    }
}</code></pre><br>
Этот метод кажется безобидным, но на самом деле он делает слишком много:<br>
<br>
<ol>
<li> Сохраняет объект</li>
<li> Обрабатывает уведомление в UI</li>
<li> Выполняет навигацию</li>
</ol><br>
Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.<br>
<br>
<b>O) Open–closed principle / Принцип открытости-закрытости</b><br>
<br>
Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.<br>
<br>
Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции.<br>
<br>
Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.<br>
<br>
<b>L) Liskov substitution principle / Принцип подстановки Лисков</b><br>
<br>
Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.<br>
<br>
<b>I) Interface segregation principle / Принцип разделения интерфейсов </b><br>
<br>
Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.<br>
<br>
<blockquote>Объекты не должны зависеть от интерфейсов, которые они не используют</blockquote><br>
<br>
ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.<br>
<br>
Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример: <br>
<br>
<pre><code class="javascript hljs">interface Animal {
  <span class="hljs-attr">eat</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>;
  walk: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>;
  fly: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>;
  swim: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>;
}</code></pre><br>
Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.<br>
<br>
<b>D) Dependency inversion principle / Принцип инверсии зависимостей </b><br>
<br>
Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.<br>
<br>
Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче.<br>
<br>
Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.<br>
<br>
В качестве примера взгляните на <a href="https://github.com/dmtrKovalenko/date-io">date-io</a>, в этой библиотеке создан тот уровень абстракции, который позволяет вам использовать её с разными источниками дат.<br>
<br>
<h3>6. Avoid Premature Optimization</h3> <i>Избегайте преждевременной оптимизации</i><br>
<br>
Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана. Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок.<br>
<br>
Поймите правильно, предвидеть, что произойдет что-то плохое – это хорошо. Но прежде чем вы погрузитесь в детали реализации, убедитесь, что эти оптимизации действительно полезны.<br>
<br>
Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости.<br>
<br>
Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок.<br>
<br>
Многие считают преждевременную оптимизацию корнем всех зол.<br>
<br>
<h3>7. Бритва Оккама</h3><br>
<blockquote>Бри́тва О́ккама (иногда ле́звие О́ккама) — методологический принцип, в кратком виде гласящий: «Не следует множить сущее без необходимости» (либо «Не следует привлекать новые сущности без крайней на то необходимости»).<br>
<br>
 — Википедия</blockquote><br>
<br>
Что это значит в мире программирования? Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.<br>
<br>
<h3>Заключение</h3><br>
Эти принципы не очень сложны. На самом деле, именно простота делает их красивыми. Если вы сбиты с толку, не пытайтесь применять все их сразу. Просто постарайтесь работать осознанно и пробуйте постепенно включать эти принципы в свой рабочий процесс.<br>
<br>
Использование базовых, но действенных принципов позволит вам стать лучшим программистом и иметь более четкое представление о том, почему вы что-то делаете.<br>
<br>
Если вы применяете большую часть принципов интуитивно, стоит задумываться и осознавать почему вы делаете что-то определенным образом.<br>
<br>
<br>
<br>
<hr><br>
